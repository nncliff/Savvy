from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import sys
import asyncio
from pathlib import Path
import random
import smtplib
import os
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
from dotenv import load_dotenv

# Add /app to path for local imports
sys.path.insert(0, "/app")

# Import and register Google provider BEFORE importing GraphRAG
try:
    from register_google_provider import register_google_providers
    register_google_providers()
except ImportError as e:
    print(f"Warning: Could not import register_google_provider: {e}")

try:
    from run_graphrag_query import GraphRAGQueryEngine
except ImportError as e:
    print(f"Error: Could not import GraphRAGQueryEngine: {e}")
    GraphRAGQueryEngine = None

# Load environment variables from .env file
load_dotenv()

app = FastAPI(title="GraphRAG Query Service")

# Initialize GraphRAG query engine
query_engine = None

@app.on_event("startup")
async def startup_event():
    """Initialize the GraphRAG query engine on startup."""
    global query_engine
    if GraphRAGQueryEngine is None:
        print("GraphRAGQueryEngine not available, skipping initialization")
        return
    
    try:
        # Try different root directories in order of preference
        potential_dirs = [
            "/app/user_storage/zhan.chen_gmail.com",
            "/app",
            "."
        ]
        
        for root_dir in potential_dirs:
            if Path(root_dir).exists():
                print(f"Attempting to initialize GraphRAG with root_dir: {root_dir}")
                query_engine = GraphRAGQueryEngine(root_dir=root_dir)
                print(f"Successfully initialized GraphRAG query engine with root_dir: {root_dir}")
                break
        else:
            print("No suitable root directory found for GraphRAG initialization")
            
    except Exception as e:
        print(f"Failed to initialize GraphRAG query engine: {str(e)}")
        # Continue without GraphRAG engine for now

async def send_email(subject: str, body: str, query: str):
    """Send email with GraphRAG results"""
    try:
        # Email configuration
        sender_email = "zhan.chen@gmail.com"
        receiver_email = "zhan.chen@gmail.com"
        app_password = os.getenv("GMAIL_APP_PASSWORD")
        
        if not app_password:
            print("GMAIL_APP_PASSWORD environment variable not set. Skipping email.")
            return False
        
        # Create message
        message = MIMEMultipart()
        message["From"] = sender_email
        message["To"] = receiver_email
        message["Subject"] = subject
        
        # Email body
        email_body = f"""
GraphRAG Random Query Results
=============================

Query: {query}
Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Results:
--------
{body}

Generated by GraphRAG Query Service
        """
        
        message.attach(MIMEText(email_body, "plain"))
        
        # Gmail SMTP configuration
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(sender_email, app_password)
        
        # Send email
        text = message.as_string()
        server.sendmail(sender_email, receiver_email, text)
        server.quit()
        
        return True
        
    except Exception as e:
        print(f"Email sending failed: {str(e)}")
        return False

class QueryRequest(BaseModel):
    query: str = "give me 2 topics related to reinforcement learning"
    method: str = "global"

class QueryResponse(BaseModel):
    result: str
    query: str
    method: str

@app.post("/query", response_model=QueryResponse)
async def graphrag_query(request: QueryRequest):
    if GraphRAGQueryEngine is None:
        raise HTTPException(status_code=503, detail="GraphRAG functionality not available - missing dependencies")
    if query_engine is None:
        raise HTTPException(status_code=500, detail="GraphRAG query engine not initialized")
    
    try:
        # Use the GraphRAG API instead of CLI
        result = await query_engine.search_async(
            query=request.query,
            search_type=request.method,
            clean_response=True  # Return clean response like CLI
        )
        
        if result.get("status") != "success":
            raise HTTPException(status_code=500, detail=f"GraphRAG failed: {result.get('error', 'Unknown error')}")
        
        return QueryResponse(result=result["result"], query=request.query, method=request.method)
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error: {str(e)}")

@app.post("/random-query", response_model=QueryResponse)
async def random_graphrag_query(request: QueryRequest):
    if GraphRAGQueryEngine is None:
        raise HTTPException(status_code=503, detail="GraphRAG functionality not available - missing dependencies")
    if query_engine is None:
        raise HTTPException(status_code=500, detail="GraphRAG query engine not initialized")
    
    # Predefined queries for random selection
    random_queries = [
        "Give me 2 topics from the index, forcing unexpected connections between distant fields",
        "Give me 2 topics from the index, looking for structural similarities across scales",
        "Give me 2 topics from the index, applying constraints from one domain to another",
        "Give me 2 topics from the index, seeking emergent properties from combinations",
        "Give me 2 topics from the index, using metaphor as a discovery tool",
        "Give me 2 topics from the index, questioning fundamental assumptions through cross-domain lenses",
        "Give me 2 topics from the index, gain new insights through the collision of these ideas"
    ]
    
    # Randomly select a query
    selected_query = random.choice(random_queries)
    
    try:
        print(f"Selected query: {selected_query}")
        print(f"Search type: {request.method}")
        
        # Use the GraphRAG API instead of CLI
        result = await query_engine.search_async(
            query=selected_query,
            search_type=request.method,
            clean_response=True  # Return clean response like CLI
        )
        
        print(f"GraphRAG result status: {result.get('status')}")
        if result.get("status") != "success":
            error_msg = result.get('error', 'Unknown error')
            print(f"GraphRAG error: {error_msg}")
            raise HTTPException(status_code=500, detail=f"GraphRAG failed: {error_msg}")
        
        print(f"GraphRAG result length: {len(str(result.get('result', '')))}")
        
        # Send email with results
        email_subject = f"GraphRAG Random Query Results - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        try:
            email_sent = await send_email(email_subject, result["result"], selected_query)
            print(f"Email sent: {email_sent}")
        except Exception as email_error:
            print(f"Email error: {email_error}")
            email_sent = False
        
        # Create response with email status
        response = QueryResponse(result=result["result"], query=selected_query, method=request.method)
        
        # Add email status to response (if needed for debugging)
        if email_sent:
            print(f"Email sent successfully for query: {selected_query}")
        else:
            print(f"Email sending failed for query: {selected_query}")
        
        return response
    
    except HTTPException:
        raise
    except Exception as e:
        print(f"Unexpected error in random_graphrag_query: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error: {str(e)}")

@app.get("/")
async def root():
    return {"message": "GraphRAG Query Service", "endpoints": ["/query", "/random-query"]}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)